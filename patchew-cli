#!/usr/bin/env python2
#
# Copyright 2016 Red Hat, Inc.
#
# Authors:
#     Fam Zheng <famz@redhat.com>
#
# This work is licensed under the MIT License.  Please see the LICENSE file or
# http://opensource.org/licenses/MIT.

import logging
import os
import sys
import argparse
import ConfigParser
import json
import urllib
import urllib2
import cookielib
import subprocess
import tempfile
import shutil
import traceback
import time
import hashlib

COOKIE_FILENAME = os.path.expanduser("~/.patchew.cookie")

class APIError(Exception):
    pass

def git_clone_repo(clone, cache_repo, remote, head, logf):
    if not os.path.isdir(cache_repo) or not os.listdir(cache_repo):
        # Clone upstream to local cache
        subprocess.check_call(["mkdir", "-p", cache_repo])
        subprocess.check_output(["git", "init", "--bare",
                                 cache_repo])
    remote_name = hashlib.sha1(remote).hexdigest()
    subprocess.call(["git", "remote", "remove", remote_name],
                    cwd=cache_repo,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
    subprocess.check_call(["git", "remote", "add", "-f", "--mirror=fetch",
                          remote_name, remote], cwd=cache_repo,
                          stdout=logf, stderr=logf)
    subprocess.check_call(["git", "clone", "-q", cache_repo, clone],
                          stderr=logf, stdout=logf)
    subprocess.check_call(["git", "checkout", head, "-b", "test"],
                          stderr=logf, stdout=logf,
                          cwd=clone)

class SubCommand(object):
    """ Base class of subcommand"""
    help = ""
    want_argv = False # Whether the command accepts extra arguments

    def api_do(self, cmd, **data):
        """Do server api call"""
        logging.debug("API call '%s':" % cmd)
        logging.debug("data:\n%s" % data)
        cookie = cookielib.MozillaCookieJar(COOKIE_FILENAME)
        try:
            cookie.load()
        except IOError:
            pass
        except cookielib.LoadError:
            print "Error while loading cookie", COOKIE_FILENAME
            pass
        handler = urllib2.HTTPCookieProcessor(cookie)
        opener = urllib2.build_opener(handler)
        url = self.base_url + "/api/" + cmd + "/"
        if data:
            post_data = urllib.urlencode({"params":
                                          json.dumps(data, ensure_ascii=False)})
        else:
            post_data = ""
        req = urllib2.Request(url, data=post_data)
        # insert data
        resp = opener.open(req)
        cookie.save(ignore_discard=True, ignore_expires=True)
        respdata = resp.read()
        logging.debug("Server response:\n%s" % (respdata or "<empty>"))
        if respdata:
            r = json.loads(respdata)
        else:
            r = None
        return r

    def do(self, args, argv):
        """Do command"""
        print("Not implemented")

class LoginCommand(SubCommand):
    name = "login"

    def arguments(self, parser):
        parser.add_argument("username", type=str, help="username for login")
        parser.add_argument("password", nargs="?",
                            type=str, help="password for login")

    def do(self, args, argv):
        import getpass
        try:
            if not args.password:
                args.password = getpass.getpass("Password: ")
            if not args.password:
                return 1
            self.api_do("login", username=args.username,
                                 password=args.password)
        except Exception as e:
            print "Login failed:", e
            return 1
        return 0

class LogoutCommand(SubCommand):
    name = "logout"

    def do(self, args, argv):
        self.api_do("logout")
        return 0

class DeleteCommand(SubCommand):
    name = "delete"
    want_argv = True

    def arguments(self, parser):
        parser.add_argument("--all", "-a", action="store_true",
                            help="Delete all messages")

    def do(self, args, argv):
        if not argv and not args.all:
            print "Must specify --all to delete all patches"
            return 1
        self.api_do("delete", terms=argv)
        return 0

class ImportCommand(SubCommand):
    name = "import"
    want_argv = True

    def arguments(self, parser):
        parser.add_argument("file", nargs="*", type=str, help="object to list")

    def do(self, args, argv):
        projects = set()
        import mailbox

        def call_import(mboxes):
            r = self.api_do("import", mboxes=mboxes)
            for p in r:
                if p not in projects:
                    projects.add(p)
                    print p

        def import_one(fn):
            if os.path.isdir(fn):
                for p in os.listdir(fn):
                    import_one(os.path.join(fn, p))
                return
            f = open(fn, "r")
            if f.readline().startswith("From "):
                for m in mailbox.mbox(fn):
                    ms = m.as_string()
                    call_import([ms])
            else:
                f.seek(0)
                call_import([f.read()])
        r = 0
        for f in args.file:
            try:
                import_one(f)
            except Exception as e:
                print "Error in importing:", f
                traceback.print_exc(e)
                r = 1
                pass
        return r

class ProjectCommand(SubCommand):
    name = "project"
    want_argv = True

    def list_projects(self, argv):
        parser = argparse.ArgumentParser()
        parser.add_argument("--raw", action="store_true",
                            help="Show raw json string")
        parser.add_argument("--verbose", "-v", action="store_true",
                            help="Show details about projects")
        args = parser.parse_args(argv)
        r = self.api_do("get-projects")
        if args.raw:
            print r
            return 0
        for p in r:
            print p["name"]
            if args.verbose:
                for k, v in p.iteritems():
                    if k == "name":
                        continue
                    print "  %s: %s" % (k, v)
        return 0

    def show_project(self, argv):
        parser = argparse.ArgumentParser()
        parser.add_argument("name", nargs="+",
                            help="The name of project to show info")
        args = parser.parse_args(argv)
        r = self.api_do("get-projects")
        for p in r:
            if not p["name"] in args.name:
                continue
            if len(args.name) > 1:
                print p["name"]
            for k, v in p.iteritems():
                if k == "name":
                    continue
                print "  %s: %s" % (k, v)
        return 0

    def add_project(self, argv):
        parser = argparse.ArgumentParser()
        parser.add_argument("name", help="Name of the project")
        parser.add_argument("--mailing-list", "-l", default="",
                            help="Mailing list")
        parser.add_argument("--url", "-u", default="",
                            help="Project URL")
        parser.add_argument("--git", "-g", default="",
                            help="Project git repo")
        parser.add_argument("--desc", "-d", default="",
                            help="Project short discription")
        args = parser.parse_args(argv)
        self.api_do("add-project",
                    name=args.name,
                    mailing_list=args.mailing_list,
                    url=args.url,
                    git=args.git,
                    description=args.desc)

    def project_property(self, argv):
        parser = argparse.ArgumentParser()
        parser.add_argument("name", help="Name of the project")
        parser.add_argument("prop", nargs="?", help="Name of the property")
        parser.add_argument("--delete", "-d", action="store_true",
                            help="""delete the property with the given name.
                            Must give a property name""")
        parser.add_argument("value", nargs="?", help="Value of the property to set")
        args = parser.parse_args(argv)
        if not args.value and not args.delete:
            # Get property and print them or the specified one
            r = self.api_do("get-project-properties",
                            project=args.name)
            if not args.prop:
                for k, v in r.iteritems() if r else []:
                    print k, v
            else:
                if r and args.prop in r:
                    print args.prop, r[args.prop]
                else:
                    print "Property Not found:", args.prop
                    if r and r.keys():
                        print "There are:", ", ".join(r.keys())
        else:
            if args.delete:
                args.value = None
            # Set property
            self.api_do("set-project-properties", project=args.name,
                        properties={args.prop: args.value})

    def do(self, args, argv):
        if argv:
            if argv[0] == "add":
                return self.add_project(argv[1:])
            elif argv[0] == "property":
                return self.project_property(argv[1:])
            elif argv[0] == "info":
                return self.show_project(argv[1:])
        return self.list_projects(argv)

class SearchCommand(SubCommand):
    name = "search"

    def arguments(self, parser):
        parser.add_argument("--output", "-o", default="subject", type=str,
                            help="Output fields")
        parser.add_argument("--raw", "-r", action="store_true",
                            help="Output raw response")
        parser.add_argument("term", nargs="*", type=str)

    def do(self, args, argv):
        r = self.api_do("search", terms=args.term)
        if not r:
            return 0
        if args.raw:
            print json.dumps(r, indent=2, separators=",:")
        else:
            for x in r:
                for a in args.output.split(","):
                    print x[a],
                print
        return 0

class UntestCommand(SubCommand):
    name = "untest"

    def arguments(self, parser):
        parser.add_argument("term", nargs="*", type=str)

    def do(self, args, argv):
        self.api_do("untest", terms=args.term)
        return 0

class SetPropertyCommand(SubCommand):
    name = "set-property"
    want_argv = True

    def arguments(self, parser):
        parser.add_argument("--project", "-p", required=True,
                            help="Project name")
        parser.add_argument("--message-id", "-m", required=True,
                            help="Project name")
        parser.add_argument("--file", action="store_true",
                            help="Read property values from given file")
        parser.add_argument("--json", action="store_true",
                            help="Read property values as json")

    def do(self, args, argv):
        if not argv:
            return 0
        if len(argv) % 2:
            print "Name and value unpaired:", argv[-1]
        props = dict(zip(argv[::2], argv[1::2]))
        if args.file:
            props = dict([(k, open(v, "r").read()) for k, v in props.iteritems()])
        if args.json:
            props = dict([(k, json.loads(v)) for k, v in props.iteritems()])
        self.api_do("set-properties", project=args.project,
                    message_id=args.message_id,
                    properties=props)
        return 0

class TesterCommand(SubCommand):
    name = "tester"
    want_argv = True

    def arguments(self, parser):
        parser.add_argument("--project", "-p", required=True,
                            help="which project to run test")
        parser.add_argument("--name", "-n",
                            help="name of this tester (default is the logged in username)")
        parser.add_argument("--num", "-N", type=int, default=0,
                            help="max number of tests to run")
        parser.add_argument("--cache-repo", "-C",
                            default=os.path.expanduser("~/.cache/patchew-tester/git-cache"),
                            help="local git repo for fast clone")

    def _make_script(self, wd, name, content):
        filename = os.path.join(wd, name)
        tf = open(filename, "wb")
        tf.write(content)
        tf.close()
        subprocess.check_output(["chmod", "+x", filename])
        return filename

    def _refresh_capabilities(self, project, name):
        wd = tempfile.mkdtemp()
        r = self.api_do("testing-capabilities",
                        project=project,
                        tester=name)
        if not r:
            return []
        ret = []
        for name, val in r.iteritems():
            script = self._make_script(wd, "probe", val)
            if 0 == subprocess.call(script,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE):
                ret.append(name)
        return ret

    def test_one(self, args, capabilities):
        r = self.api_do("testing-get", project=args.project, tester=args.name,
                                    capabilities=capabilities)
        if not r:
            return False
        print "Running test '%s'" % r["test"]["name"]
        if r["project"] != args.project:
            return

        wd = tempfile.mkdtemp(prefix="patchew-tester-tmp-", dir="/var/tmp/")
        print "  Workdir:", wd
        logf = open(os.path.join(wd, "log"), "w+b")
        test_cmd = r["test"]["script"]
        script = r["test"]["script"].strip() + "\n"
        test_script = self._make_script(wd, "run", script)
        for k, v in r["identity"].iteritems():
            logf.write("%s: %s\n" % (k.capitalize(), v))
        logf.write("\n")
        logf.write("=== TEST SCRIPT BEGIN ===\n")
        logf.write(script)
        logf.write("=== TEST SCRIPT END ===\n")
        logf.write("\n")
        logf.flush()
        rc = 1
        try:
            clone = os.path.join(wd, "src")
            git_clone_repo(clone, args.cache_repo, r["repo"], r["head"], logf)
            base = r["base"]
            if base:
                subprocess.check_call(["git", "branch", "base", base],
                                      cwd=clone, stdout=logf, stderr=logf)
                subprocess.check_call(["git", "log", "--oneline", "%s.." % (base)],
                                      cwd=clone, stdout=logf, stderr=logf)
            logf.write("\n")
            logf.write("=== OUTPUT BEGIN ===\n")
            logf.flush()
            start_time = time.time()
            tp = subprocess.Popen([test_script], cwd=clone,
                                  stdout=logf, stderr=logf)
            rc = None
            timeout = r["test"]["timeout"]
            while timeout <= 0 or time.time() - start_time < timeout:
                rc = tp.poll()
                if rc != None:
                    break
                time.sleep(0.1)
            logf.write("=== OUTPUT END ===\n")
            logf.write("\n")
            if rc == None:
                logf.write("Abort: command timeout (>%d seconds)" % timeout)
            else:
                logf.write("Test command exited with code: %d" % rc)
            logf.flush()
        except Exception as e:
            traceback.print_exc(e, logf)
        finally:
            passed = rc == 0
            logf.seek(0)
            log = logf.read()
            print "  Result:", "Passed" if passed else "Failed"
            logging.debug(log)
            self.api_do("testing-report", project=r["project"],
                                          identity=r["identity"],
                                          test=r["test"]["name"],
                                          tester=args.name,
                                          head=r["head"],
                                          base=r["base"],
                                          passed=passed,
                                          log=log)
            logf.close()
            shutil.rmtree(wd)
            return True

    def do(self, args, argv):
        # Make sure git works
        subprocess.check_output(["git", "version"])
        rest = False
        count = 0
        cap_refresh = 10
        while True:
            try:
                if count % cap_refresh == 0:
                    capabilities = self._refresh_capabilities(args.project,
                                                              args.name)
                count += 1
                if self.test_one(args, capabilities=capabilities):
                    rest = False
                    continue
                if count == args.num:
                    break
                if not rest:
                    print "No more work, having a rest..."
                    rest = True
                time.sleep(60)
            except Exception as e:
                traceback.print_exc(e)
                # Wait longer in case of an exception
                time.sleep(600)
        return 0

class ApplyCommand(SubCommand):
    name = "apply"

    def arguments(self, parser):
        parser.add_argument("term", nargs="*", type=str)
        parser.add_argument("-C", dest="repo",
                            help="The path to the git repo")
        parser.add_argument("--any", "-a", action="store_true",
                            help="""Apply any applicable series (e.g. the
                            first) even if there are more than one matches""")
        parser.add_argument("--branch", "-b",
                            help="""Create a branch at current HEAD before
                            applying, with '%m' replaced with the series'
                            message id""")
        parser.add_argument("--force-branch", "-B",
                            help="""Create a branch, overwrite even if a branch
                            with the same name already exists, and point to
                            current HEAD before applying, with '%m' replaced
                            with the series' message id""")
        parser.add_argument("--tag", "-t",
                            help="""Create a tag after applying, with '%m'
                            replaced with the series' message id. If a tag with
                            the same name already exists, it will be
                            updated""")
        parser.add_argument("--applier-mode", action="store_true",
                            help="""Useful for an applier worker of patchew.
                            Must be run in an empty directory, which will be
                            used as the working repo. Clone and checkout a
                            temporary repo, and apply the patch there. Implies
                            --any, conflicts with -C, -b, -B and -t.""")

    def _apply(self, repo, s, branch, force_branch, tag, logf=None):
        msgid = s["message-id"]
        if force_branch:
            bn = force_branch
            bo = "-B"
        elif branch:
            bn = branch
            bo = "-b"
        if bn:
            bn = bn.replace("%m", msgid)
            subprocess.check_call(["git", "checkout", bo, bn], cwd=repo,
                                  stdout=logf, stderr=logf)
        for p in s["patches"]:
            patchf = tempfile.NamedTemporaryFile()
            patchf.write(p["mbox"])
            patchf.flush()
            if 0 != subprocess.call(["git", "am", "-m", "-3", patchf.name],
                                    cwd=repo, stdout=logf, stderr=logf):
                return 1
            filter_cmd = ""
            commit_message_lines = \
                    subprocess.check_output(["git", "log", "-n", "1",
                                             "--format=%b"], cwd=repo) \
                                           .splitlines()
            for t in set(p["properties"].get("tags", []) + \
                         s["properties"].get("tags", [])):
                if t in commit_message_lines:
                    continue
                filter_cmd += "echo '%s';" % t
            if filter_cmd:
                subprocess.check_output(["git", "filter-branch", "-f",
                                         "--msg-filter", "cat; " + filter_cmd,
                                         "HEAD~1.."], cwd=repo)
        if tag:
            subprocess.check_call(["git", "tag", "-f",
                                  tag.replace("%m", msgid)], cwd=repo,
                                  stdout=logf, stderr=logf)
        return 0

    def _push(self, repo, remote, tag, logf):
        subprocess.check_call(["git", "remote", "add", "push_to", remote],
                              cwd=repo, stdout=logf, stderr=logf)
        subprocess.check_call(["git", "push", "-f", "push_to",
                               "%s:refs/tags/%s" % (tag, tag)],
                              cwd=repo, stdout=logf, stderr=logf)

    def _applier_mode(self, r, args):
        toapply = None
        for c in r:
            if c.get("git-need-apply"):
                toapply = c
                break
        if not toapply:
            print "No series need apply"
            return 3
        logf = tempfile.NamedTemporaryFile()
        try:
            cache_repo = os.path.expanduser("~/.cache/patchew-repos/" + c["project"])
            project_git = toapply["project.git"]
            if " " in project_git:
                remote, head = project_git.split(" ", 2)
            else:
                remote, head = project_git, "master"
            repo = "."
            git_clone_repo(repo, cache_repo, remote, head, sys.stdout)
            branch = toapply["message-id"]
            force_branch = None
            tag = "patchew/" + toapply["message-id"]
            base = subprocess.check_output(["git", "rev-parse", "HEAD"])
            self._apply(repo, toapply, branch, force_branch, tag, logf)
            push_repo = toapply["git.push_to"]
            self._push(repo, push_repo, tag, logf)
            url = toapply["git.url_template"].replace("%t", tag)
            logf.seek(0)
            self.api_do("set-properties",
                        project=toapply["project"],
                        message_id=toapply["message-id"],
                        properties={
                            "git.tag": tag,
                            "git.url": url,
                            "git.base": base,
                            "git.repo": push_repo,
                            "git.apply-failed": False,
                            "git.apply-log": logf.read(),
                        })
            return 0
        except Exception, e:
            traceback.print_exc(e, logf)
            logf.seek(0)
            log = logf.read()
            print log
            self.api_do("set-properties",
                        project=toapply["project"],
                        message_id=toapply["message-id"],
                        properties={
                            "git.apply-failed": True,
                            "git.apply-log": log,
                        })
            return 1

    def do(self, args, argv):
        if args.applier_mode:
            if args.repo or args.branch or args.force_branch or args.tag:
                print "--applier-mode conflicts with -C, -b, -B and -t"
                return 1
            args.any = True
            args.term = args.term + ["!has:git.apply-log", "is:complete"]
        r = self.api_do("search", terms=args.term)
        if not r:
            print "Nothing to apply"
            return 3
        if len(r) > 1 and not args.any:
            print "More than one series matched:"
            for p in r:
                print r["project"], r["subject"]
            return 1
        if not r[0]["is_complete"]:
            print "Series not complete"
            return 1
        if args.applier_mode:
            return self._applier_mode(r, args)
        def mformat(a):
            return a.replace("%m", r[0]["message-id"]) if a else a
        self._apply(args.repo, r[0],
                    mformat(args.branch),
                    mformat(args.force_branch),
                    mformat(args.tag))


def global_args(parser):
    parser.add_argument("-d", "--debug", action="store_true", default=None,
                        help="Enable debug output")
    parser.add_argument("-D", "--nodebug", action="store_false", dest="debug",
                        help="Disable debug output")
    parser.add_argument("-s", "--server",
                        help="Base URL for patchew server")
    parser.add_argument("-c", "--config",
                        help="""Config file to use. Default is to look up
                        .patchew.cfg under current directory and $HOME""")

def args_merge_config(args):
    if not args.config:
        for fp in [".patchew.cfg", os.path.expanduser("~/.patchew.cfg")]:
            if os.path.isfile(fp):
                args.config = fp
                break
    if not args.config:
        return
    cp = ConfigParser.ConfigParser()
    cp.read(args.config)
    if args.debug == None:
        args.debug = cp.getboolean("general", "debug")
    if args.server == None:
        args.server = cp.get("general", "server")

def main():
    parser = argparse.ArgumentParser()
    global_args(parser)
    subparsers = parser.add_subparsers(title="subcommands")
    for c in SubCommand.__subclasses__():
        cmd = c()
        p = subparsers.add_parser(cmd.name, help=cmd.help)
        if hasattr(cmd, "arguments"):
            cmd.arguments(p)
        p.set_defaults(cmdobj=cmd, all=False)
    args, argv = parser.parse_known_args()

    args_merge_config(args)

    if not hasattr(args, "cmdobj"):
        parser.print_usage()
        return 1
    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
        logging.debug("Server: %s", args.server)
    if argv and not args.cmdobj.want_argv:
        raise Exception("Unrecognized arguments:\n" + argv[0])
    base_url = args.server
    if base_url.endswith("/"):
        base_url = base_url[:-1]
    args.cmdobj.base_url = base_url
    return args.cmdobj.do(args, argv)

if __name__ == '__main__':
    sys.exit(main())

